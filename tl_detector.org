#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+DATE: \today

#+OPTIONS: ^:nil

#+TITLE: Design and Construction of tl_detector (traffic light detector)


* Source Code

Here we construct the source code from top to bottom.

#+NAME:tl_dectector
#+BEGIN_SRC python :noweb tangle :tangle
  #!/usr/bin/env python
  <<imports>>
  STATE_COUNT_THRESHOLD = 3

  class TLDetector(object):
      def __init__(self):
          rospy.init_node('tl_detector')
          <<attributes-initialization>>
          <<subscribers>>
          config_string = rospy.get_param("/traffic_light_config")
          self.config = yaml.load(config_string)
          self.upcoming_red_light_pub = rospy.Publisher('/traffic_waypoint', Int32, queue_size=1)
          <<traffic_image_processing_initialization>>
          <<traffic_light_initialization>>
          rospy.spin()
      <<waypoints_cb>>
      <<pose_cb>>
      <<traffic_cb>>
      <<image_cb>>
      <<get_closest_waypoint>>
      <<get_light_state>>
      <<process_traffic_lights>>

  if __name__ == '__main__':
      try:
          TLDetector()
      except rospy.ROSInterruptException:
          rospy.logerr('Could not start traffic node.')
#+END_SRC

** imports

#+NAME:imports
#+BEGIN_SRC python :noweb tangle :tangle
  import rospy
  from std_msgs.msg import Int32
  from geometry_msgs.msg import PoseStamped, Pose
  from styx_msgs.msg import TrafficLightArray, TrafficLight
  from styx_msgs.msg import Lane
  from sensor_msgs.msg import Image
  from cv_bridge import CvBridge
  from light_classification.tl_classifier import TLClassifier
  import tf
  import cv2
  import yaml
#+END_SRC

** attributes-initialization

self.lights is from TrafficLightArray.lights, the position and state of traffic lights.

#+NAME:attributes-initialization
#+BEGIN_SRC python :noweb tangle :tangle
  self.pose = None
  self.waypoints = None
  self.camera_image = None
  self.lights = []
#+END_SRC

** subscribers

#+NAME:subscribers
#+BEGIN_SRC python :noweb tangle :tangle
  sub1 = rospy.Subscriber('/current_pose', PoseStamped, self.pose_cb)
  sub2 = rospy.Subscriber('/base_waypoints', Lane, self.waypoints_cb)

  '''
  /vehicle/traffic_lights provides you with the location of the traffic light in 3D map space and
  helps you acquire an accurate ground truth data source for the traffic light
  classifier by sending the current color state of all traffic lights in the
  simulator. When testing on the vehicle, the color state will not be available. You'll need to
  rely on the position of the light and the camera image to predict it.
  '''
  sub3 = rospy.Subscriber('/vehicle/traffic_lights', TrafficLightArray, self.traffic_cb)
  sub6 = rospy.Subscriber('/image_color', Image, self.image_cb)

#+END_SRC

** traffic_light_initialization

#+NAME:traffic_light_initialization
#+BEGIN_SRC python :noweb tangle :tangle
  self.state = TrafficLight.UNKNOWN
  self.last_state = TrafficLight.UNKNOWN
  self.last_wp = -1
  self.state_count = 0

#+END_SRC

** traffic_image_processing_initialization

#+NAME:traffic_image_processing_initialization
#+BEGIN_SRC python :noweb tangle :tangle
  self.bridge = CvBridge()
  self.light_classifier = TLClassifier()
  self.listener = tf.TransformListener()

#+END_SRC

** waypoints_cb

#+NAME:waypoints_cb
#+BEGIN_SRC python :noweb tangle :tangle
def waypoints_cb(self, waypoints):
    self.waypoints = waypoints

#+END_SRC

** pose_cb

#+NAME:pose_cb
#+BEGIN_SRC python :noweb tangle :tangle
def pose_cb(self, msg):
    self.pose = msg

#+END_SRC

** traffic_cb

#+NAME:traffic_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def traffic_cb(self, msg):
      self.lights = msg.lights

#+END_SRC

** image_cb

   Delegate the processing of the image, recognition to self.process_traffic_lights

   Publish stable recognition outcome in terms of /traffic_waypoint (index)


#+NAME:image_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def image_cb(self, msg):
      """Identifies red lights in the incoming camera image and publishes the index
              of the waypoint closest to the red light's stop line to /traffic_waypoint

          Args:
              msg (Image): image from car-mounted camera

      """
      self.has_image = True
      self.camera_image = msg
      light_wp, state = self.process_traffic_lights()

      '''
          Publish upcoming red lights at camera frequency.
          Each predicted state has to occur `STATE_COUNT_THRESHOLD` number
          of times till we start using it. Otherwise the previous stable state is
          used.
      '''
      if self.state != state:
          self.state_count = 0
          self.state = state
      elif self.state_count >= STATE_COUNT_THRESHOLD:
          self.last_state = self.state
          light_wp = light_wp if state == TrafficLight.RED else -1
          self.last_wp = light_wp
          self.upcoming_red_light_pub.publish(Int32(light_wp))
      else:
          self.upcoming_red_light_pub.publish(Int32(self.last_wp))
      # end of if self.state != state
      self.state_count += 1

#+END_SRC

** process_traffic_lights

#+NAME:process_traffic_lights
#+BEGIN_SRC python :noweb tangle :tangle
  def process_traffic_lights(self):
      """Finds closest visible traffic light, if one exists, and determines its
          location and color

      Returns:
          int: index of waypoint closes to the upcoming stop line for a traffic light (-1 if none exists)
          int: ID of traffic light color (specified in styx_msgs/TrafficLight)

      """
      light = None

      # List of positions that correspond to the line to stop in front of for a given intersection
      stop_line_positions = self.config['stop_line_positions']
      if (self.pose):
          car_position = self.get_closest_waypoint(self.pose.pose)
      # end of if (self.pose)

      #TODO find the closest visible traffic light (if one exists)

      if light:
          state = self.get_light_state(light)
          return light_wp, state
      self.waypoints = None
      return -1, TrafficLight.UNKNOWN

#+END_SRC

** get_closest_waypoint

#+NAME:get_closest_waypoint
#+BEGIN_SRC python :noweb tangle :tangle
      def get_closest_waypoint(self, pose):
          """Identifies the closest path waypoint to the given position
              https://en.wikipedia.org/wiki/Closest_pair_of_points_problem
          Args:
              pose (Pose): position to match a waypoint to

          Returns:
              int: index of the closest waypoint in self.waypoints

          """
          #TODO implement
          return 0

#+END_SRC

** get_light_state

#+NAME:get_light_state
#+BEGIN_SRC python :noweb tangle :tangle
      def get_light_state(self, light):
          """Determines the current color of the traffic light

          Args:
              light (TrafficLight): light to classify

          Returns:
              int: ID of traffic light color (specified in styx_msgs/TrafficLight)

          """
          if(not self.has_image):
              self.prev_light_loc = None
              return False

          cv_image = self.bridge.imgmsg_to_cv2(self.camera_image, "bgr8")

          #Get classification
          return self.light_classifier.get_classification(cv_image)

#+END_SRC
